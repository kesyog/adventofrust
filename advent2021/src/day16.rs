//! Solution to [AoC 2021 Day 16](https://adventofcode.com/2021/day/16)
//! Forced myself to use nom parser combinators and bit-aware parsing

mod parse {
    use super::{Literal, Packet, Payload};
    use nom::bits::complete::take;
    use nom::multi::count;
    use nom::IResult;
    use std::str::FromStr;

    // A bitstream (generated by nom::bits::bits)
    type BitstreamInput<'a> = (&'a [u8], usize);

    fn subpackets_by_length(
        input: BitstreamInput,
    ) -> IResult<BitstreamInput, (Vec<Packet>, usize)> {
        let (mut remaining, bits_to_read) = take(15_u8)(input)?;

        let mut subpackets = Vec::new();
        let mut subpacket_bits_read = 0;
        loop {
            let (remaining_new, (subpacket, bits_read)) = packet(remaining)?;
            // Workaround around destructuring assignments not yet being stable
            remaining = remaining_new;
            subpacket_bits_read += bits_read;
            subpackets.push(subpacket);
            assert!(
                subpacket_bits_read <= bits_to_read,
                "Subpackets did not match specified bitlength"
            );
            if subpacket_bits_read == bits_to_read {
                return Ok((remaining, (subpackets, 15 + bits_to_read)));
            }
        }
    }

    fn subpackets_by_count(input: BitstreamInput) -> IResult<BitstreamInput, (Vec<Packet>, usize)> {
        let (remaining, n_subpackets) = take(11_u8)(input)?;
        let (remaining, packets_and_bitlengths) = count(packet, n_subpackets)(remaining)?;
        let (packets, bitlengths): (_, Vec<usize>) = packets_and_bitlengths.into_iter().unzip();
        Ok((
            remaining,
            (packets, bitlengths.into_iter().sum::<usize>() + 11),
        ))
    }

    /// Returns the operator packet's subpackets and the number of bits read
    fn operator_payload(input: BitstreamInput) -> IResult<BitstreamInput, (Vec<Packet>, usize)> {
        let (remaining, length_id) = take(1_u8)(input)?;
        let (remaining, (subpackets, subpacket_bitlength)) = match length_id {
            0 => subpackets_by_length(remaining)?,
            1 => subpackets_by_count(remaining)?,
            _ => unreachable!(),
        };
        Ok((remaining, (subpackets, 1 + subpacket_bitlength)))
    }

    /// Returns a literal value and the number of bits read
    fn literal_value(input: BitstreamInput) -> IResult<BitstreamInput, (Literal, usize)> {
        let mut output: u64 = 0;
        let mut remaining = input;
        let mut n_nibbles: usize = 0;
        loop {
            let (remaining_new, nibble): (BitstreamInput, u8) = take(5_u8)(remaining)?;
            // Workaround around destructuring assignments not yet being stable
            remaining = remaining_new;
            n_nibbles += 1;
            output = (output << 4) | u64::from(nibble & 0b1111);
            if nibble & 0b10000 == 0 {
                return IResult::Ok((remaining, (output.into(), 5 * n_nibbles)));
            }
        }
    }

    fn version(input: BitstreamInput) -> IResult<BitstreamInput, u8> {
        take(3_u8)(input)
    }

    fn id(input: BitstreamInput) -> IResult<BitstreamInput, u8> {
        take(3_u8)(input)
    }

    /// Returns a Packet and the number of bits read
    fn packet(input: BitstreamInput) -> IResult<BitstreamInput, (Packet, usize)> {
        let (remaining, version) = version(input)?;
        let (remaining, id) = id(remaining)?;
        let (remaining, payload, payload_length) = match id {
            Packet::LITERAL_ID => {
                let (remaining, (inner, n_bits_read)) = literal_value(remaining)?;
                (remaining, Payload::Literal(inner), n_bits_read)
            }
            id => {
                let (remaining, (subpackets, n_bits_read)) = operator_payload(remaining)?;
                (
                    remaining,
                    Payload::from_operator_id(id, subpackets),
                    n_bits_read,
                )
            }
        };
        let n_bits_read = 3 + 3 + payload_length;
        let output = Packet { version, payload };
        Ok((remaining, (output, n_bits_read)))
    }

    impl FromStr for Packet {
        type Err = String;

        fn from_str(s: &str) -> Result<Self, Self::Err> {
            let bytestream = hex::decode(s).map_err(|_| s.to_owned())?;
            let (_, (packet, _)) = packet((&bytestream, 0)).map_err(|_| s.to_owned())?;
            Ok(packet)
        }
    }

    #[cfg(test)]
    mod tests {
        use super::*;

        #[test]
        fn test_literal() {
            let packet = "D2FE28".parse::<Packet>().expect("Parsing error");
            assert_eq!(
                packet,
                Packet {
                    version: 6,
                    payload: Payload::Literal(Literal(2021))
                }
            );
        }

        #[test]
        fn test_op_by_count() {
            let packet = "EE00D40C823060".parse::<Packet>().expect("Parsing error");
            assert_eq!(
                packet,
                Packet {
                    version: 7,
                    payload: Payload::Maximum(vec![
                        Packet {
                            version: 2,
                            payload: Payload::Literal(Literal(1))
                        },
                        Packet {
                            version: 4,
                            payload: Payload::Literal(Literal(2))
                        },
                        Packet {
                            version: 1,
                            payload: Payload::Literal(Literal(3))
                        },
                    ]),
                }
            );
        }

        #[test]
        fn test_op_by_bitlength() {
            let packet = "38006F45291200".parse::<Packet>().expect("Parsing error");
            assert_eq!(
                packet,
                Packet {
                    version: 1,
                    payload: Payload::LessThan(vec![
                        Packet {
                            version: 6,
                            payload: Payload::Literal(Literal(10))
                        },
                        Packet {
                            version: 2,
                            payload: Payload::Literal(Literal(20))
                        },
                    ]),
                }
            );
        }
    }
}

#[derive(Debug, Copy, Clone, PartialEq)]
struct Literal(u64);

impl<T> From<T> for Literal
where
    T: Into<u64>,
{
    fn from(inner: T) -> Self {
        Self(inner.into())
    }
}

#[derive(Debug, Clone, PartialEq)]
enum Payload {
    Literal(Literal),
    Sum(Vec<Packet>),
    Product(Vec<Packet>),
    Minimum(Vec<Packet>),
    Maximum(Vec<Packet>),
    GreaterThan(Vec<Packet>),
    LessThan(Vec<Packet>),
    Equals(Vec<Packet>),
}

impl Payload {
    fn from_operator_id(id: u8, subpackets: Vec<Packet>) -> Self {
        use Payload::*;

        match id {
            0 => Sum(subpackets),
            1 => Product(subpackets),
            2 => Minimum(subpackets),
            3 => Maximum(subpackets),
            5 => GreaterThan(subpackets),
            6 => LessThan(subpackets),
            7 => Equals(subpackets),
            id => panic!("Invalid operator id: {}", id),
        }
    }

    fn subpackets(&self) -> Option<&[Packet]> {
        use Payload::*;

        match self {
            Sum(subpackets)
            | Product(subpackets)
            | Minimum(subpackets)
            | Maximum(subpackets)
            | GreaterThan(subpackets)
            | LessThan(subpackets)
            | Equals(subpackets) => Some(subpackets),
            Literal(_) => None,
        }
    }
}

#[derive(Debug, Clone, PartialEq)]
struct Packet {
    version: u8,
    payload: Payload,
}

impl Packet {
    const LITERAL_ID: u8 = 4;

    fn evaluate(&self) -> u64 {
        match &self.payload {
            Payload::Literal(literal) => literal.0,
            Payload::Sum(subpackets) => subpackets.iter().map(Self::evaluate).sum(),
            Payload::Product(subpackets) => subpackets.iter().map(Self::evaluate).product(),
            Payload::Minimum(subpackets) => subpackets.iter().map(Self::evaluate).min().unwrap(),
            Payload::Maximum(subpackets) => subpackets.iter().map(Self::evaluate).max().unwrap(),
            Payload::GreaterThan(subpackets) => {
                u64::from(subpackets[0].evaluate() > subpackets[1].evaluate())
            }
            Payload::LessThan(subpackets) => {
                u64::from(subpackets[0].evaluate() < subpackets[1].evaluate())
            }
            Payload::Equals(subpackets) => {
                u64::from(subpackets[0].evaluate() == subpackets[1].evaluate())
            }
        }
    }
}

fn part1(input: &Packet) -> usize {
    // Return sum of all version numbers
    let mut version_sum = 0;
    let mut to_visit = vec![input];
    while let Some(packet) = to_visit.pop() {
        version_sum += usize::from(packet.version);
        if let Some(subpackets) = packet.payload.subpackets() {
            to_visit.extend(subpackets.iter());
        }
    }
    version_sum
}

fn part2(input: &Packet) -> u64 {
    input.evaluate()
}

fn main() {
    let input = include_str!("../inputs/day16.txt");
    let input = input.trim();
    assert!(
        input.len() % 2 == 0,
        "Input {} has odd ({}) number of bytes",
        input,
        input.len()
    );
    let input = input.parse::<Packet>().expect("Parsing error");

    println!("Part 1: {}", part1(&input));
    println!("Part 2: {}", part2(&input));
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn given_part1_input() {
        let input = "8A004A801A8002F478".parse::<Packet>().unwrap();
        assert_eq!(16, part1(&input));
        let input = "620080001611562C8802118E34".parse::<Packet>().unwrap();
        assert_eq!(12, part1(&input));
        let input = "C0015000016115A2E0802F182340".parse::<Packet>().unwrap();
        assert_eq!(23, part1(&input));
        let input = "A0016C880162017C3686B18A3D4780".parse::<Packet>().unwrap();
        assert_eq!(31, part1(&input));
    }

    #[test]
    fn given_part2_input() {
        let input = "C200B40A82".parse::<Packet>().unwrap();
        assert_eq!(3, part2(&input));
        let input = "04005AC33890".parse::<Packet>().unwrap();
        assert_eq!(54, part2(&input));
        let input = "880086C3E88112".parse::<Packet>().unwrap();
        assert_eq!(7, part2(&input));
        let input = "CE00C43D881120".parse::<Packet>().unwrap();
        assert_eq!(9, part2(&input));
        let input = "D8005AC2A8F0".parse::<Packet>().unwrap();
        assert_eq!(1, part2(&input));
        let input = "F600BC2D8F".parse::<Packet>().unwrap();
        assert_eq!(0, part2(&input));
        let input = "9C005AC2F8F0".parse::<Packet>().unwrap();
        assert_eq!(0, part2(&input));
        let input = "9C0141080250320F1802104A08".parse::<Packet>().unwrap();
        assert_eq!(1, part2(&input));
    }
}
